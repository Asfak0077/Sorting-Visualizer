<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Enhanced Sorting Visualizer — Advanced Animations & Functions</title>
    <meta name="description" content="Advanced sorting visualizer with 10+ algorithms, sound effects, themes, step mode, and stunning animations" />
    <style>
      :root {
        --bg: #0a0a0f;
        --bg-2: #12121a;
        --panel: #1a1a25;
        --panel-2: #20202d;
        --text: #e8e8f0;
        --text-muted: #a8a8b8;
        --text-dim: #888898;
        
        --primary: #6366f1;
        --primary-light: #818cf8;
        --secondary: #06b6d4;
        --accent: #f59e0b;
        --success: #10b981;
        --danger: #ef4444;
        --warning: #f59e0b;
        --purple: #8b5cf6;
        --pink: #ec4899;
        
        --compare-color: #f59e0b;
        --swap-color: #ef4444;
        --pivot-color: #06b6d4;
        --sorted-color: #10b981;
        --selected-color: #8b5cf6;
        
        --shadow-sm: 0 2px 8px rgba(0,0,0,0.15);
        --shadow-md: 0 4px 16px rgba(0,0,0,0.25);
        --shadow-lg: 0 8px 32px rgba(0,0,0,0.35);
        --shadow-glow: 0 0 20px rgba(99,102,241,0.3);
        
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        
        --transition-fast: 80ms;
        --transition-normal: 150ms;
        --transition-slow: 300ms;
        
        --animation-duration: 200ms;
        --bar-gap: 3px;
      }

      [data-theme="light"] {
        --bg: #f8fafc;
        --bg-2: #f1f5f9;
        --panel: #ffffff;
        --panel-2: #f8fafc;
        --text: #1e293b;
        --text-muted: #64748b;
        --text-dim: #94a3b8;
      }

      [data-theme="neon"] {
        --bg: #000008;
        --bg-2: #0a0a18;
        --panel: #0f0f20;
        --panel-2: #151528;
        --primary: #00ff88;
        --secondary: #ff0088;
        --accent: #ffaa00;
        --compare-color: #ffaa00;
        --swap-color: #ff0088;
        --pivot-color: #00aaff;
        --sorted-color: #00ff88;
        --selected-color: #aa00ff;
      }

      [data-theme="ocean"] {
        --bg: #0c1445;
        --bg-2: #1e2a78;
        --panel: #2d3a8c;
        --panel-2: #3c4aa0;
        --primary: #60a5fa;
        --secondary: #34d399;
        --accent: #fbbf24;
        --compare-color: #fbbf24;
        --swap-color: #f87171;
        --pivot-color: #34d399;
        --sorted-color: #60a5fa;
        --selected-color: #a78bfa;
      }

      * { box-sizing: border-box; }

      html, body {
        height: 100%;
        margin: 0;
        background: 
          radial-gradient(circle at 20% 20%, rgba(99,102,241,0.15) 0%, transparent 50%),
          radial-gradient(circle at 80% 80%, rgba(139,92,246,0.15) 0%, transparent 50%),
          radial-gradient(circle at 40% 60%, rgba(6,182,212,0.1) 0%, transparent 50%),
          linear-gradient(135deg, var(--bg) 0%, var(--bg-2) 100%);
        color: var(--text);
        font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, sans-serif;
        overflow-x: hidden;
      }

      body {
        display: grid;
        grid-template-rows: auto auto 1fr auto;
        gap: 16px;
      }

      /* Animations */
      @keyframes slideInUp {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }

      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }

      @keyframes bounce {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-8px); }
      }

      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-4px); }
        75% { transform: translateX(4px); }
      }

      @keyframes glow {
        0%, 100% { box-shadow: 0 0 5px currentColor; }
        50% { box-shadow: 0 0 20px currentColor, 0 0 30px currentColor; }
      }

      @keyframes ripple {
        0% { transform: scale(0.8); opacity: 1; }
        100% { transform: scale(2.4); opacity: 0; }
      }

      @keyframes sparkle {
        0%, 100% { opacity: 0; transform: scale(0) rotate(0deg); }
        50% { opacity: 1; transform: scale(1) rotate(180deg); }
      }

      @keyframes float {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
      }

      /* Header */
      header {
        padding: 20px 24px;
        background: linear-gradient(135deg, rgba(99,102,241,0.1) 0%, rgba(139,92,246,0.1) 100%);
        border-bottom: 1px solid rgba(255,255,255,0.1);
        backdrop-filter: blur(10px);
        animation: slideInUp 0.6s ease-out;
      }

      .header-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 16px;
        max-width: 1400px;
        margin: 0 auto;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .brand-icon {
        width: 40px;
        height: 40px;
        background: conic-gradient(from 45deg, var(--primary), var(--secondary), var(--accent), var(--primary));
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-glow);
        animation: float 3s ease-in-out infinite;
      }

      h1 {
        margin: 0;
        font-size: clamp(18px, 3vw, 24px);
        font-weight: 700;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .theme-controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      /* Controls */
      .controls {
        padding: 0 24px;
        max-width: 1400px;
        margin: 0 auto;
        animation: slideInUp 0.8s ease-out;
      }

      .control-panels {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      }

      .panel {
        background: linear-gradient(135deg, var(--panel) 0%, var(--panel-2) 100%);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: var(--radius-lg);
        padding: 20px;
        box-shadow: var(--shadow-md);
        backdrop-filter: blur(10px);
        transition: transform var(--transition-normal) ease, box-shadow var(--transition-normal) ease;
      }

      .panel:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
      }

      .panel-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-muted);
        margin-bottom: 16px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .form-grid {
        display: grid;
        gap: 16px;
      }

      .form-row {
        display: flex;
        gap: 12px;
        align-items: end;
      }

      .form-group {
        flex: 1;
      }

      label {
        display: block;
        font-size: 12px;
        color: var(--text-muted);
        margin-bottom: 6px;
        font-weight: 500;
      }

      select, input[type="range"], input[type="number"], input[type="text"] {
        width: 100%;
        padding: 10px 12px;
        background: rgba(0,0,0,0.3);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: var(--radius-sm);
        color: var(--text);
        font-size: 14px;
        transition: all var(--transition-normal) ease;
      }

      select:focus, input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99,102,241,0.2);
      }

      input[type="range"] {
        accent-color: var(--primary);
      }

      .btn {
        padding: 10px 16px;
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
        border: none;
        border-radius: var(--radius-sm);
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal) ease;
        position: relative;
        overflow: hidden;
      }

      .btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.5s;
      }

      .btn:hover::before {
        left: 100%;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn.secondary {
        background: linear-gradient(135deg, var(--secondary) 0%, #22d3ee 100%);
      }

      .btn.accent {
        background: linear-gradient(135deg, var(--accent) 0%, #fcd34d 100%);
      }

      .btn.danger {
        background: linear-gradient(135deg, var(--danger) 0%, #f87171 100%);
      }

      .btn.success {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .btn-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .btn-sm {
        padding: 6px 12px;
        font-size: 12px;
      }

      /* Theme Selector */
      .theme-btn {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 2px solid transparent;
        cursor: pointer;
        transition: all var(--transition-normal) ease;
      }

      .theme-btn.active {
        border-color: var(--primary);
        box-shadow: 0 0 0 2px rgba(99,102,241,0.3);
      }

      .theme-dark { background: linear-gradient(135deg, #0a0a0f, #1a1a25); }
      .theme-light { background: linear-gradient(135deg, #f8fafc, #ffffff); }
      .theme-neon { background: linear-gradient(135deg, #000008, #00ff88); }
      .theme-ocean { background: linear-gradient(135deg, #0c1445, #60a5fa); }

      /* Metrics */
      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 12px;
      }

      .metric {
        background: rgba(0,0,0,0.3);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: var(--radius-sm);
        padding: 12px;
        text-align: center;
      }

      .metric-label {
        font-size: 11px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .metric-value {
        font-size: 20px;
        font-weight: 700;
        margin-top: 4px;
        font-variant-numeric: tabular-nums;
      }

      /* Visualizer */
      main {
        padding: 0 24px;
        max-width: 1400px;
        margin: 0 auto;
        animation: slideInUp 1s ease-out;
      }

      .visualizer {
        background: linear-gradient(135deg, var(--panel) 0%, var(--panel-2) 100%);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: var(--radius-lg);
        padding: 20px;
        box-shadow: var(--shadow-lg);
        backdrop-filter: blur(10px);
      }

      .viz-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }

      .complexity-info {
        font-size: 12px;
        color: var(--text-muted);
        background: rgba(0,0,0,0.3);
        padding: 8px 12px;
        border-radius: var(--radius-sm);
      }

      .bars-container {
        height: min(60vh, 500px);
        min-height: 300px;
        background: 
          radial-gradient(circle at 30% 30%, rgba(99,102,241,0.05) 0%, transparent 50%),
          radial-gradient(circle at 70% 70%, rgba(139,92,246,0.05) 0%, transparent 50%),
          linear-gradient(180deg, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.4) 100%);
        border: 2px dashed rgba(255,255,255,0.1);
        border-radius: var(--radius-md);
        padding: 16px;
        display: flex;
        align-items: end;
        gap: var(--bar-gap);
        position: relative;
        overflow: hidden;
      }

      .bars-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
          repeating-linear-gradient(
            0deg,
            transparent 0px,
            rgba(255,255,255,0.02) 1px,
            transparent 2px,
            transparent 40px
          );
        pointer-events: none;
      }

      .bar {
        flex: 1;
        min-width: 2px;
        background: linear-gradient(180deg, #4f46e5, #3730a3);
        border-radius: 4px 4px 0 0;
        transition: 
          height var(--animation-duration) cubic-bezier(0.4, 0, 0.2, 1),
          background var(--transition-normal) ease,
          transform var(--transition-normal) ease,
          box-shadow var(--transition-normal) ease;
        position: relative;
        cursor: pointer;
        box-shadow: 
          0 0 0 1px rgba(255,255,255,0.1),
          inset 0 1px 0 rgba(255,255,255,0.2);
      }

      .bar::before {
        content: '';
        position: absolute;
        top: -4px;
        left: 50%;
        transform: translateX(-50%);
        width: 6px;
        height: 6px;
        background: currentColor;
        border-radius: 50%;
        opacity: 0;
        transition: opacity var(--transition-normal) ease;
      }

      .bar:hover::before {
        opacity: 0.6;
      }

      .bar::after {
        content: attr(data-value);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 10px;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--transition-normal) ease;
        margin-bottom: 8px;
      }

      .bar:hover::after {
        opacity: 1;
      }

      /* Bar States */
      .bar.compare {
        background: linear-gradient(180deg, var(--compare-color), #d97706) !important;
        transform: translateY(-4px) scale(1.02);
        box-shadow: 
          0 0 20px rgba(245,158,11,0.4),
          0 0 0 2px rgba(245,158,11,0.6);
        animation: pulse 0.6s ease-in-out;
      }

      .bar.compare::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        border: 2px solid var(--compare-color);
        border-radius: 50%;
        animation: ripple 0.6s ease-out;
      }

      .bar.swap {
        background: linear-gradient(180deg, var(--swap-color), #dc2626) !important;
        transform: translateY(-6px) scale(1.05);
        box-shadow: 
          0 0 25px rgba(239,68,68,0.5),
          0 0 0 2px rgba(239,68,68,0.7);
        animation: shake 0.5s ease-in-out;
      }

      .bar.pivot {
        background: linear-gradient(180deg, var(--pivot-color), #0891b2) !important;
        transform: scale(1.1);
        box-shadow: 
          0 0 30px rgba(6,182,212,0.6),
          0 0 0 3px rgba(6,182,212,0.8);
        animation: glow 1s ease-in-out infinite;
      }

      .bar.sorted {
        background: linear-gradient(180deg, var(--sorted-color), #059669) !important;
        box-shadow: 
          0 0 15px rgba(16,185,129,0.4),
          0 0 0 1px rgba(16,185,129,0.6);
        animation: bounce 0.8s ease-in-out;
      }

      .bar.selected {
        background: linear-gradient(180deg, var(--selected-color), #7c3aed) !important;
        transform: translateY(-3px);
        box-shadow: 
          0 0 20px rgba(139,92,246,0.5),
          0 0 0 2px rgba(139,92,246,0.7);
      }

      /* Particles */
      .particle {
        position: absolute;
        width: 4px;
        height: 4px;
        background: var(--primary);
        border-radius: 50%;
        pointer-events: none;
        animation: sparkle 1s ease-out forwards;
      }

      /* Sound Controls */
      .sound-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        padding: 8px;
        border-radius: var(--radius-sm);
        transition: background var(--transition-normal) ease;
      }

      .sound-toggle:hover {
        background: rgba(255,255,255,0.1);
      }

      .sound-icon {
        width: 20px;
        height: 20px;
        fill: currentColor;
      }

      /* Step Mode */
      .step-controls {
        display: none;
        gap: 8px;
        align-items: center;
      }

      .step-controls.active {
        display: flex;
      }

      /* Algorithm Info */
      .algo-info {
        background: rgba(0,0,0,0.3);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: var(--radius-sm);
        padding: 12px;
        margin-top: 16px;
      }

      .algo-description {
        font-size: 13px;
        color: var(--text-muted);
        line-height: 1.5;
      }

      /* Status */
      .status {
        margin-top: 16px;
        padding: 12px;
        background: rgba(0,0,0,0.3);
        border-radius: var(--radius-sm);
        font-size: 14px;
        text-align: center;
        border-left: 4px solid var(--primary);
      }

      /* Footer */
      footer {
        padding: 20px 24px;
        text-align: center;
        color: var(--text-dim);
        font-size: 12px;
        border-top: 1px solid rgba(255,255,255,0.1);
      }

      /* Responsive */
      @media (max-width: 768px) {
        .header-content {
          flex-direction: column;
          text-align: center;
        }
        
        .control-panels {
          grid-template-columns: 1fr;
        }
        
        .form-row {
          flex-direction: column;
        }
        
        .btn-group {
          justify-content: center;
        }
        
        .metrics {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      /* Accessibility */
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      /* Custom Scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--primary-light);
      }

      /* Input/Output Display Styles */
      .input-output-display {
        padding: 0 24px;
        max-width: 1400px;
        margin: 0 auto 16px;
        animation: slideInUp 1.2s ease-out;
      }

      .io-panels {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 16px;
      }

      .io-panel {
        min-height: 120px;
      }

      .array-display {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .array-values {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        max-height: 80px;
        overflow-y: auto;
        padding: 8px;
        background: rgba(0,0,0,0.2);
        border-radius: var(--radius-sm);
        border: 1px solid rgba(255,255,255,0.1);
      }

      .array-value {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 32px;
        height: 24px;
        padding: 0 6px;
        background: linear-gradient(135deg, var(--primary), var(--primary-light));
        color: white;
        border-radius: 4px;
        font-size: 11px;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
        transition: all var(--transition-normal) ease;
        cursor: pointer;
      }

      .array-value:hover {
        transform: scale(1.1);
        z-index: 10;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      }

      .array-value.highlight {
        background: linear-gradient(135deg, var(--accent), #fcd34d);
        animation: pulse 0.6s ease-in-out;
      }

      .array-value.sorted {
        background: linear-gradient(135deg, var(--success), #34d399);
      }

      .array-value.comparing {
        background: linear-gradient(135deg, var(--compare-color), #fbbf24);
        animation: shake 0.5s ease-in-out;
      }

      .array-value.swapping {
        background: linear-gradient(135deg, var(--swap-color), #f87171);
        animation: bounce 0.8s ease-in-out;
      }

      .array-stats {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 12px;
        color: var(--text-muted);
      }

      .array-stats strong {
        color: var(--text);
        font-variant-numeric: tabular-nums;
      }

      /* Enhanced bar value display */
      .bar-value-label {
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        color: var(--text-muted);
        font-weight: 600;
        font-variant-numeric: tabular-nums;
        opacity: 0;
        transition: opacity var(--transition-normal) ease;
        pointer-events: none;
      }

      .bars-container:hover .bar-value-label {
        opacity: 1;
      }

      .bar.active .bar-value-label {
        opacity: 1;
        color: var(--text);
        font-weight: 700;
      }

      /* Value comparison display */
      .value-comparison {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.8);
        padding: 8px 12px;
        border-radius: var(--radius-sm);
        font-size: 12px;
        color: white;
        opacity: 0;
        transition: opacity var(--transition-normal) ease;
        pointer-events: none;
      }

      .value-comparison.show {
        opacity: 1;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .io-panels {
          grid-template-columns: 1fr;
        }
        
        .array-values {
          max-height: 60px;
        }
        
        .array-value {
          min-width: 28px;
          height: 20px;
          font-size: 10px;
        }
      }
    </style>
  </head>
  <body data-theme="dark">
    <header>
      <div class="header-content">
        <div class="brand">
          <div class="brand-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 3v18h18"/>
              <path d="M7 16V8"/>
              <path d="M11 16V4"/>
              <path d="M15 16v-6"/>
              <path d="M19 16V10"/>
            </svg>
          </div>
          <div>
            <h1>Enhanced Sorting Visualizer</h1>
            <div style="font-size: 12px; color: var(--text-muted);">Advanced Animations & Functions</div>
          </div>
        </div>
        
        <div class="theme-controls">
          <div class="sound-toggle" id="soundToggle">
            <svg class="sound-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
              <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
            </svg>
            <span>Sound</span>
          </div>
          
          <div style="display: flex; gap: 4px;">
            <div class="theme-btn theme-dark active" data-theme="dark" title="Dark Theme"></div>
            <div class="theme-btn theme-light" data-theme="light" title="Light Theme"></div>
            <div class="theme-btn theme-neon" data-theme="neon" title="Neon Theme"></div>
            <div class="theme-btn theme-ocean" data-theme="ocean" title="Ocean Theme"></div>
          </div>
        </div>
      </div>
    </header>

    <section class="controls">
      <div class="control-panels">
        <div class="panel">
          <div class="panel-title">Algorithm & Settings</div>
          <div class="form-grid">
            <div class="form-group">
              <label for="algorithm">Sorting Algorithm</label>
              <select id="algorithm">
                <option value="bubble">Bubble Sort</option>
                <option value="selection">Selection Sort</option>
                <option value="insertion">Insertion Sort</option>
                <option value="merge">Merge Sort</option>
                <option value="quick">Quick Sort</option>
                <option value="heap">Heap Sort</option>
                <option value="shell">Shell Sort</option>
                <option value="cocktail">Cocktail Shaker Sort</option>
                <option value="comb">Comb Sort</option>
                <option value="radix">Radix Sort</option>
              </select>
            </div>
            
            <div class="form-row">
              <div class="form-group">
                <label for="arraySize">Size: <span id="sizeValue">50</span></label>
                <input type="range" id="arraySize" min="5" max="200" value="50">
              </div>
              <div class="form-group">
                <label for="speed">Speed: <span id="speedValue">50</span></label>
                <input type="range" id="speed" min="1" max="100" value="50">
              </div>
            </div>
            
            <div class="form-group">
              <label for="distribution">Initial Distribution</label>
              <select id="distribution">
                <option value="random">Random</option>
                <option value="nearly">Nearly Sorted</option>
                <option value="reversed">Reversed</option>
                <option value="few-unique">Few Unique Values</option>
                <option value="custom">Custom Input</option>
              </select>
            </div>
            
            <div class="form-group" id="customInputGroup" style="display: none;">
              <label for="customInput">Custom Array (comma-separated)</label>
              <input type="text" id="customInput" placeholder="e.g., 64,34,25,12,22,11,90">
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Controls</div>
          <div class="form-grid">
            <div class="btn-group">
              <button class="btn secondary" id="generateBtn">Generate New</button>
              <button class="btn" id="shuffleBtn">Shuffle</button>
            </div>
            
            <div class="btn-group">
              <button class="btn success" id="startBtn">Start Sorting</button>
              <button class="btn accent" id="pauseBtn" disabled>Pause</button>
              <button class="btn danger" id="stopBtn" disabled>Stop</button>
            </div>
            
            <div class="step-controls" id="stepControls">
              <button class="btn btn-sm" id="stepBackBtn">← Step Back</button>
              <button class="btn btn-sm" id="stepForwardBtn">Step Forward →</button>
            </div>
            
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
              <input type="checkbox" id="stepMode">
              <span>Step-by-step Mode</span>
            </label>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Metrics</div>
          <div class="metrics">
            <div class="metric">
              <div class="metric-label">Comparisons</div>
              <div class="metric-value" id="comparisons">0</div>
            </div>
            <div class="metric">
              <div class="metric-label">Swaps</div>
              <div class="metric-value" id="swaps">0</div>
            </div>
            <div class="metric">
              <div class="metric-label">Array Access</div>
              <div class="metric-value" id="arrayAccess">0</div>
            </div>
            <div class="metric">
              <div class="metric-label">Time</div>
              <div class="metric-value" id="timeElapsed">0.00s</div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Quick Actions</div>
          <div class="form-grid">
            <div class="btn-group">
              <button class="btn btn-sm" onclick="setPreset(10, 90)">Fast Demo</button>
              <button class="btn btn-sm" onclick="setPreset(50, 50)">Balanced</button>
              <button class="btn btn-sm" onclick="setPreset(100, 20)">Detailed</button>
            </div>
            
            <div class="btn-group">
              <button class="btn btn-sm secondary" id="exportBtn">Export Array</button>
              <button class="btn btn-sm secondary" id="importBtn">Import Array</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="input-output-display">
      <div class="io-panels">
        <div class="panel io-panel">
          <div class="panel-title">Input Array</div>
          <div class="array-display" id="inputArray">
            <div class="array-values" id="inputValues"></div>
            <div class="array-stats" id="inputStats">
              <span>Min: <strong id="inputMin">-</strong></span>
              <span>Max: <strong id="inputMax">-</strong></span>
              <span>Avg: <strong id="inputAvg">-</strong></span>
            </div>
          </div>
        </div>
        
        <div class="panel io-panel">
          <div class="panel-title">Current State</div>
          <div class="array-display" id="currentArray">
            <div class="array-values" id="currentValues"></div>
            <div class="array-stats" id="currentStats">
              <span>Sorted: <strong id="sortedPercentage">0%</strong></span>
              <span>Position: <strong id="currentPosition">-</strong></span>
            </div>
          </div>
        </div>
        
        <div class="panel io-panel">
          <div class="panel-title">Output Array</div>
          <div class="array-display" id="outputArray">
            <div class="array-values" id="outputValues"></div>
            <div class="array-stats" id="outputStats">
              <span>Status: <strong id="outputStatus">Not Started</strong></span>
              <span>Efficiency: <strong id="efficiency">-</strong></span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <main>
      <div class="visualizer">
        <div class="viz-header">
          <div class="panel-title">Array Visualization</div>
          <div class="complexity-info" id="complexityInfo">
            Time: O(n²) | Space: O(1)
          </div>
        </div>
        
        <div class="bars-container" id="barsContainer">
           Bars will be generated here 
        </div>
        
        <div class="algo-info" id="algoInfo">
          <div class="algo-description" id="algoDescription">
            Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.
          </div>
        </div>
        
        <div class="status" id="status">Ready to sort! Select an algorithm and click Start.</div>
      </div>
    </main>

    <footer>
      <p>Enhanced Sorting Visualizer with 10+ algorithms, sound effects, themes, and advanced animations. Built with pure HTML, CSS, and JavaScript.</p>
    </footer>

    <script>
      // Audio Context for Sound Effects
      let audioContext;
      let soundEnabled = true;

      function initAudio() {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('Audio not supported');
          soundEnabled = false;
        }
      }

      function playSound(frequency, duration = 100, type = 'sine') {
        if (!soundEnabled || !audioContext) return;
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration / 1000);
      }

      // Global State
      let array = [];
      let originalArray = [];
      let isRunning = false;
      let isPaused = false;
      let isStepping = false;
      let animationSpeed = 50;
      let currentStep = 0;
      let sortingSteps = [];
      
      // Metrics
      let comparisons = 0;
      let swaps = 0;
      let arrayAccesses = 0;
      let startTime = 0;
      let timerInterval;

      // DOM Elements
      const elements = {
        algorithm: document.getElementById('algorithm'),
        arraySize: document.getElementById('arraySize'),
        speed: document.getElementById('speed'),
        distribution: document.getElementById('distribution'),
        customInput: document.getElementById('customInput'),
        customInputGroup: document.getElementById('customInputGroup'),
        generateBtn: document.getElementById('generateBtn'),
        shuffleBtn: document.getElementById('shuffleBtn'),
        startBtn: document.getElementById('startBtn'),
        pauseBtn: document.getElementById('pauseBtn'),
        stopBtn: document.getElementById('stopBtn'),
        stepMode: document.getElementById('stepMode'),
        stepControls: document.getElementById('stepControls'),
        stepBackBtn: document.getElementById('stepBackBtn'),
        stepForwardBtn: document.getElementById('stepForwardBtn'),
        barsContainer: document.getElementById('barsContainer'),
        status: document.getElementById('status'),
        sizeValue: document.getElementById('sizeValue'),
        speedValue: document.getElementById('speedValue'),
        comparisons: document.getElementById('comparisons'),
        swaps: document.getElementById('swaps'),
        arrayAccess: document.getElementById('arrayAccess'),
        timeElapsed: document.getElementById('timeElapsed'),
        complexityInfo: document.getElementById('complexityInfo'),
        algoDescription: document.getElementById('algoDescription'),
        soundToggle: document.getElementById('soundToggle'),
        exportBtn: document.getElementById('exportBtn'),
        importBtn: document.getElementById('importBtn')
      };

      // Algorithm Information
      const algorithmInfo = {
        bubble: {
          name: 'Bubble Sort',
          timeComplexity: 'O(n²)',
          spaceComplexity: 'O(1)',
          description: 'Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.'
        },
        selection: {
          name: 'Selection Sort',
          timeComplexity: 'O(n²)',
          spaceComplexity: 'O(1)',
          description: 'Selection Sort divides the input list into two parts: a sorted portion at the left end and an unsorted portion at the right end. It repeatedly selects the smallest element from the unsorted portion.'
        },
        insertion: {
          name: 'Insertion Sort',
          timeComplexity: 'O(n²)',
          spaceComplexity: 'O(1)',
          description: 'Insertion Sort builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.'
        },
        merge: {
          name: 'Merge Sort',
          timeComplexity: 'O(n log n)',
          spaceComplexity: 'O(n)',
          description: 'Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.'
        },
        quick: {
          name: 'Quick Sort',
          timeComplexity: 'O(n log n)',
          spaceComplexity: 'O(log n)',
          description: 'Quick Sort is a divide-and-conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot.'
        },
        heap: {
          name: 'Heap Sort',
          timeComplexity: 'O(n log n)',
          spaceComplexity: 'O(1)',
          description: 'Heap Sort is a comparison-based sorting technique based on Binary Heap data structure. It first builds a max heap from the input data, then repeatedly extracts the maximum element.'
        },
        shell: {
          name: 'Shell Sort',
          timeComplexity: 'O(n log n)',
          spaceComplexity: 'O(1)',
          description: 'Shell Sort is a generalization of insertion sort that allows the exchange of items that are far apart. It starts by sorting pairs of elements far apart from each other, then progressively reducing the gap.'
        },
        cocktail: {
          name: 'Cocktail Shaker Sort',
          timeComplexity: 'O(n²)',
          spaceComplexity: 'O(1)',
          description: 'Cocktail Shaker Sort is a variation of Bubble Sort that sorts in both directions on each pass through the list. It can be slightly more efficient than bubble sort.'
        },
        comb: {
          name: 'Comb Sort',
          timeComplexity: 'O(n²)',
          spaceComplexity: 'O(1)',
          description: 'Comb Sort improves on bubble sort by using a gap larger than 1. The gap starts large and shrinks by a factor of 1.3 in every iteration until it reaches the value 1.'
        },
        radix: {
          name: 'Radix Sort',
          timeComplexity: 'O(nk)',
          spaceComplexity: 'O(n+k)',
          description: 'Radix Sort is a non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix (digit).'
        }
      };

      // Utility Functions
      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function shuffle(arr) {
        const newArr = [...arr];
        for (let i = newArr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
        }
        return newArr;
      }

      function generateArray(size, type) {
        let arr = [];
        
        switch (type) {
          case 'random':
            arr = Array.from({ length: size }, () => randomInt(5, 100));
            break;
          case 'nearly':
            arr = Array.from({ length: size }, (_, i) => Math.floor((i / size) * 95) + 5);
            // Add some disorder
            for (let i = 0; i < size * 0.1; i++) {
              const idx1 = randomInt(0, size - 1);
              const idx2 = randomInt(0, size - 1);
              [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
            }
            break;
          case 'reversed':
            arr = Array.from({ length: size }, (_, i) => Math.floor(((size - i - 1) / size) * 95) + 5);
            break;
          case 'few-unique':
            const values = [10, 25, 40, 55, 70, 85];
            arr = Array.from({ length: size }, () => values[randomInt(0, values.length - 1)]);
            break;
          case 'custom':
            const input = elements.customInput.value.trim();
            if (input) {
              arr = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x) && x > 0);
              if (arr.length === 0) {
                arr = Array.from({ length: size }, () => randomInt(5, 100));
              }
            } else {
              arr = Array.from({ length: size }, () => randomInt(5, 100));
            }
            break;
        }
        
        return arr;
      }

      function createParticle(x, y, color) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        particle.style.background = color;
        elements.barsContainer.appendChild(particle);
        
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, 1000);
      }

      function renderBars() {
        elements.barsContainer.innerHTML = '';
        const containerHeight = elements.barsContainer.clientHeight - 32;
        const maxValue = Math.max(...array);
        
        array.forEach((value, index) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.height = `${(value / maxValue) * containerHeight}px`;
          bar.dataset.value = value;
          bar.dataset.index = index;
          
          // Add value label
          const label = document.createElement('div');
          label.className = 'bar-value-label';
          label.textContent = value;
          bar.appendChild(label);
          
          bar.addEventListener('click', () => {
            if (!isRunning) {
              highlightBarByIndex(index);
              playSound(200 + value * 5, 150);
            }
          });
          
          elements.barsContainer.appendChild(bar);
        });
        
        // Update displays
        updateCurrentDisplay();
      }

      function updateBar(index, value, className = '') {
        const bars = elements.barsContainer.children;
        if (bars[index]) {
          const containerHeight = elements.barsContainer.clientHeight - 32;
          const maxValue = Math.max(...array);
          bars[index].style.height = `${(value / maxValue) * containerHeight}px`;
          bars[index].dataset.value = value;
          
          if (className) {
            bars[index].className = `bar ${className}`;
            setTimeout(() => {
              if (bars[index]) {
                bars[index].className = 'bar';
              }
            }, 300);
          }
        }
      }

      function highlightBars(indices, className) {
        const bars = elements.barsContainer.children;
        indices.forEach(index => {
          if (bars[index]) {
            bars[index].classList.add(className);
          }
        });
        
        // Update current display
        highlightCurrentValues(indices, className === 'compare' ? 'comparing' : 'swapping');
        
        // Show value comparison for compare operations
        if (className === 'compare' && indices.length === 2) {
          showValueComparison(indices[0], indices[1], 'compare');
        } else if (className === 'swap' && indices.length === 2) {
          showValueComparison(indices[0], indices[1], 'swap');
        }
      }

      function clearHighlights() {
        const bars = elements.barsContainer.children;
        Array.from(bars).forEach(bar => {
          bar.className = 'bar';
        });
      }

      function markSorted(indices) {
        const bars = elements.barsContainer.children;
        indices.forEach(index => {
          if (bars[index]) {
            bars[index].classList.add('sorted');
          }
        });
      }

      // Metrics Functions
      function resetMetrics() {
        comparisons = 0;
        swaps = 0;
        arrayAccesses = 0;
        startTime = Date.now();
        
        elements.comparisons.textContent = '0';
        elements.swaps.textContent = '0';
        elements.arrayAccess.textContent = '0';
        elements.timeElapsed.textContent = '0.00s';
        
        if (timerInterval) {
          clearInterval(timerInterval);
        }
        
        timerInterval = setInterval(() => {
          const elapsed = (Date.now() - startTime) / 1000;
          elements.timeElapsed.textContent = elapsed.toFixed(2) + 's';
        }, 10);
      }

      function updateMetrics() {
        elements.comparisons.textContent = comparisons.toString();
        elements.swaps.textContent = swaps.toString();
        elements.arrayAccess.textContent = arrayAccesses.toString();
      }

      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      // Sorting Algorithms
      async function bubbleSort() {
        const n = array.length;
        for (let i = 0; i < n - 1; i++) {
          let swapped = false;
          for (let j = 0; j < n - i - 1; j++) {
            if (!isRunning) return;
            
            // Highlight comparison
            highlightBars([j, j + 1], 'compare');
            comparisons++;
            arrayAccesses += 2;
            updateMetrics();
            playSound(300 + array[j] * 3, 100);
            
            await sleep(getDelay());
            
            if (array[j] > array[j + 1]) {
              // Swap
              [array[j], array[j + 1]] = [array[j + 1], array[j]];
              updateBar(j, array[j], 'swap');
              updateBar(j + 1, array[j + 1], 'swap');
              swaps++;
              swapped = true;
              playSound(150, 150, 'square');
              
              // Create particles
              const bar1 = elements.barsContainer.children[j];
              const bar2 = elements.barsContainer.children[j + 1];
              if (bar1 && bar2) {
                const rect1 = bar1.getBoundingClientRect();
                const rect2 = bar2.getBoundingClientRect();
                createParticle(rect1.left, rect1.top, '#ef4444');
                createParticle(rect2.left, rect2.top, '#ef4444');
              }
            }
            
            clearHighlights();
            await sleep(getDelay() / 2);
          }
          
          // Mark as sorted
          markSorted([n - i - 1]);
          playSound(500, 200, 'triangle');
          
          if (!swapped) break;
        }
        
        // Mark all as sorted
        markSorted(Array.from({ length: n }, (_, i) => i));
      }

      async function selectionSort() {
        const n = array.length;
        for (let i = 0; i < n - 1; i++) {
          if (!isRunning) return;
          
          let minIdx = i;
          highlightBars([minIdx], 'selected');
          
          for (let j = i + 1; j < n; j++) {
            if (!isRunning) return;
            
            highlightBars([j, minIdx], 'compare');
            comparisons++;
            arrayAccesses += 2;
            updateMetrics();
            playSound(250 + array[j] * 2, 80);
            
            await sleep(getDelay());
            
            if (array[j] < array[minIdx]) {
              clearHighlights();
              minIdx = j;
              highlightBars([minIdx], 'selected');
            } else {
              clearHighlights();
              highlightBars([minIdx], 'selected');
            }
          }
          
          if (minIdx !== i) {
            [array[i], array[minIdx]] = [array[minIdx], array[i]];
            updateBar(i, array[i], 'swap');
            updateBar(minIdx, array[minIdx], 'swap');
            swaps++;
            playSound(180, 200, 'sawtooth');
          }
          
          clearHighlights();
          markSorted([i]);
          await sleep(getDelay());
        }
        
        markSorted([n - 1]);
      }

      async function insertionSort() {
        const n = array.length;
        for (let i = 1; i < n; i++) {
          if (!isRunning) return;
          
          const key = array[i];
          let j = i - 1;
          
          highlightBars([i], 'selected');
          await sleep(getDelay());
          
          while (j >= 0 && array[j] > key) {
            if (!isRunning) return;
            
            highlightBars([j, j + 1], 'compare');
            comparisons++;
            arrayAccesses += 2;
            updateMetrics();
            playSound(200 + array[j] * 2, 60);
            
            await sleep(getDelay());
            
            array[j + 1] = array[j];
            updateBar(j + 1, array[j + 1], 'swap');
            swaps++;
            j--;
            
            clearHighlights();
          }
          
          array[j + 1] = key;
          updateBar(j + 1, key);
          clearHighlights();
          await sleep(getDelay() / 2);
        }
        
        markSorted(Array.from({ length: n }, (_, i) => i));
      }

      async function mergeSort(arr = array, left = 0, right = array.length - 1) {
        if (left >= right) return;
        if (!isRunning) return;
        
        const mid = Math.floor((left + right) / 2);
        
        await mergeSort(arr, left, mid);
        await mergeSort(arr, mid + 1, right);
        await merge(arr, left, mid, right);
      }

      async function merge(arr, left, mid, right) {
        if (!isRunning) return;
        
        const leftArr = arr.slice(left, mid + 1);
        const rightArr = arr.slice(mid + 1, right + 1);
        
        let i = 0, j = 0, k = left;
        
        while (i < leftArr.length && j < rightArr.length) {
          if (!isRunning) return;
          
          highlightBars([k], 'compare');
          comparisons++;
          arrayAccesses += 2;
          updateMetrics();
          playSound(300 + leftArr[i] * 2, 80);
          
          await sleep(getDelay());
          
          if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            updateBar(k, leftArr[i], 'swap');
            i++;
          } else {
            arr[k] = rightArr[j];
            updateBar(k, rightArr[j], 'swap');
            j++;
          }
          
          swaps++;
          k++;
          clearHighlights();
        }
        
        while (i < leftArr.length) {
          if (!isRunning) return;
          arr[k] = leftArr[i];
          updateBar(k, leftArr[i]);
          i++;
          k++;
          await sleep(getDelay() / 3);
        }
        
        while (j < rightArr.length) {
          if (!isRunning) return;
          arr[k] = rightArr[j];
          updateBar(k, rightArr[j]);
          j++;
          k++;
          await sleep(getDelay() / 3);
        }
        
        // Mark merged section as temporarily sorted
        for (let idx = left; idx <= right; idx++) {
          const bar = elements.barsContainer.children[idx];
          if (bar) {
            bar.style.boxShadow = '0 0 10px rgba(16,185,129,0.5)';
            setTimeout(() => {
              if (bar) bar.style.boxShadow = '';
            }, 500);
          }
        }
      }

      async function quickSort(arr = array, low = 0, high = array.length - 1) {
        if (low < high && isRunning) {
          const pi = await partition(arr, low, high);
          await quickSort(arr, low, pi - 1);
          await quickSort(arr, pi + 1, high);
        }
      }

      async function partition(arr, low, high) {
        if (!isRunning) return low;
        
        const pivot = arr[high];
        highlightBars([high], 'pivot');
        playSound(400, 300, 'triangle');
        
        let i = low - 1;
        
        for (let j = low; j < high; j++) {
          if (!isRunning) return i + 1;
          
          highlightBars([j, high], 'compare');
          comparisons++;
          arrayAccesses += 2;
          updateMetrics();
          playSound(250 + arr[j] * 2, 60);
          
          await sleep(getDelay());
          
          if (arr[j] < pivot) {
            i++;
            if (i !== j) {
              [arr[i], arr[j]] = [arr[j], arr[i]];
              updateBar(i, arr[i], 'swap');
              updateBar(j, arr[j], 'swap');
              swaps++;
              playSound(150, 100, 'square');
            }
          }
          
          clearHighlights();
          highlightBars([high], 'pivot');
        }
        
        [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
        updateBar(i + 1, arr[i + 1], 'swap');
        updateBar(high, arr[high], 'swap');
        swaps++;
        
        clearHighlights();
        markSorted([i + 1]);
        
        return i + 1;
      }

      async function heapSort() {
        const n = array.length;
        
        // Build max heap
        for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
          await heapify(n, i);
        }
        
        // Extract elements from heap one by one
        for (let i = n - 1; i > 0; i--) {
          if (!isRunning) return;
          
          [array[0], array[i]] = [array[i], array[0]];
          updateBar(0, array[0], 'swap');
          updateBar(i, array[i], 'swap');
          swaps++;
          playSound(200, 150, 'sawtooth');
          
          markSorted([i]);
          await heapify(i, 0);
        }
        
        markSorted([0]);
      }

      async function heapify(n, i) {
        if (!isRunning) return;
        
        let largest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        
        if (left < n) {
          highlightBars([left, largest], 'compare');
          comparisons++;
          arrayAccesses += 2;
          updateMetrics();
          playSound(300 + array[left] * 2, 60);
          await sleep(getDelay());
          
          if (array[left] > array[largest]) {
            largest = left;
          }
          clearHighlights();
        }
        
        if (right < n) {
          highlightBars([right, largest], 'compare');
          comparisons++;
          arrayAccesses += 2;
          updateMetrics();
          playSound(300 + array[right] * 2, 60);
          await sleep(getDelay());
          
          if (array[right] > array[largest]) {
            largest = right;
          }
          clearHighlights();
        }
        
        if (largest !== i) {
          [array[i], array[largest]] = [array[largest], array[i]];
          updateBar(i, array[i], 'swap');
          updateBar(largest, array[largest], 'swap');
          swaps++;
          playSound(180, 120, 'square');
          
          await sleep(getDelay());
          await heapify(n, largest);
        }
      }

      async function shellSort() {
        const n = array.length;
        let gap = Math.floor(n / 2);
        
        while (gap > 0) {
          if (!isRunning) return;
          
          for (let i = gap; i < n; i++) {
            if (!isRunning) return;
            
            const temp = array[i];
            let j = i;
            
            highlightBars([i], 'selected');
            await sleep(getDelay());
            
            while (j >= gap && array[j - gap] > temp) {
              if (!isRunning) return;
              
              highlightBars([j, j - gap], 'compare');
              comparisons++;
              arrayAccesses += 2;
              updateMetrics();
              playSound(250 + array[j] * 2, 80);
              
              await sleep(getDelay());
              
              array[j] = array[j - gap];
              updateBar(j, array[j], 'swap');
              swaps++;
              j -= gap;
              
              clearHighlights();
            }
            
            array[j] = temp;
            updateBar(j, temp);
            clearHighlights();
          }
          
          gap = Math.floor(gap / 2);
        }
        
        markSorted(Array.from({ length: n }, (_, i) => i));
      }

      async function cocktailSort() {
        const n = array.length;
        let swapped = true;
        let start = 0;
        let end = n - 1;
        
        while (swapped) {
          if (!isRunning) return;
          
          swapped = false;
          
          // Forward pass
          for (let i = start; i < end; i++) {
            if (!isRunning) return;
            
            highlightBars([i, i + 1], 'compare');
            comparisons++;
            arrayAccesses += 2;
            updateMetrics();
            playSound(300 + array[i] * 2, 80);
            
            await sleep(getDelay());
            
            if (array[i] > array[i + 1]) {
              [array[i], array[i + 1]] = [array[i + 1], array[i]];
              updateBar(i, array[i], 'swap');
              updateBar(i + 1, array[i + 1], 'swap');
              swaps++;
              swapped = true;
              playSound(150, 120, 'square');
            }
            
            clearHighlights();
          }
          
          if (!swapped) break;
          
          markSorted([end]);
          end--;
          swapped = false;
          
          // Backward pass
          for (let i = end - 1; i >= start; i--) {
            if (!isRunning) return;
            
            highlightBars([i, i + 1], 'compare');
            comparisons++;
            arrayAccesses += 2;
            updateMetrics();
            playSound(300 + array[i] * 2, 80);
            
            await sleep(getDelay());
            
            if (array[i] > array[i + 1]) {
              [array[i], array[i + 1]] = [array[i + 1], array[i]];
              updateBar(i, array[i], 'swap');
              updateBar(i + 1, array[i + 1], 'swap');
              swaps++;
              swapped = true;
              playSound(150, 120, 'square');
            }
            
            clearHighlights();
          }
          
          markSorted([start]);
          start++;
        }
        
        markSorted(Array.from({ length: n }, (_, i) => i));
      }

      async function combSort() {
        const n = array.length;
        let gap = n;
        const shrink = 1.3;
        let sorted = false;
        
        while (!sorted) {
          if (!isRunning) return;
          
          gap = Math.floor(gap / shrink);
          if (gap <= 1) {
            gap = 1;
            sorted = true;
          }
          
          let i = 0;
          while (i + gap < n) {
            if (!isRunning) return;
            
            highlightBars([i, i + gap], 'compare');
            comparisons++;
            arrayAccesses += 2;
            updateMetrics();
            playSound(280 + array[i] * 2, 70);
            
            await sleep(getDelay());
            
            if (array[i] > array[i + gap]) {
              [array[i], array[i + gap]] = [array[i + gap], array[i]];
              updateBar(i, array[i], 'swap');
              updateBar(i + gap, array[i + gap], 'swap');
              swaps++;
              sorted = false;
              playSound(150, 120, 'square');
            }
            
            clearHighlights();
            i++;
          }
        }
        
        markSorted(Array.from({ length: n }, (_, i) => i));
      }

      async function radixSort() {
        const max = Math.max(...array);
        const maxDigits = max.toString().length;
        
        for (let digit = 0; digit < maxDigits; digit++) {
          if (!isRunning) return;
          
          const buckets = Array.from({ length: 10 }, () => []);
          
          // Distribute elements into buckets
          for (let i = 0; i < array.length; i++) {
            if (!isRunning) return;
            
            highlightBars([i], 'selected');
            const digitValue = Math.floor(array[i] / Math.pow(10, digit)) % 10;
            buckets[digitValue].push(array[i]);
            arrayAccesses++;
            updateMetrics();
            playSound(200 + digitValue * 50, 100);
            
            await sleep(getDelay() / 2);
            clearHighlights();
          }
          
          // Collect elements from buckets
          let index = 0;
          for (let bucket = 0; bucket < 10; bucket++) {
            for (let item of buckets[bucket]) {
              if (!isRunning) return;
              
              array[index] = item;
              updateBar(index, item, 'swap');
              swaps++;
              index++;
              
              await sleep(getDelay() / 3);
            }
          }
          
          await sleep(getDelay());
        }
        
        markSorted(Array.from({ length: array.length }, (_, i) => i));
      }

      // Utility Functions
      function sleep(ms) {
        return new Promise(resolve => {
          if (isPaused) {
            const checkPause = () => {
              if (!isPaused || !isRunning) {
                setTimeout(resolve, ms);
              } else {
                setTimeout(checkPause, 50);
              }
            };
            checkPause();
          } else {
            setTimeout(resolve, ms);
          }
        });
      }

      function getDelay() {
        return Math.max(10, 1000 - (animationSpeed * 10));
      }

      function setPreset(size, speed) {
        elements.arraySize.value = size;
        elements.speed.value = speed;
        elements.sizeValue.textContent = size;
        elements.speedValue.textContent = speed;
        animationSpeed = speed;
        generateNewArray();
      }

      function generateNewArray() {
        if (isRunning) return;
        
        const size = parseInt(elements.arraySize.value);
        const distribution = elements.distribution.value;
        
        array = generateArray(size, distribution);
        originalArray = [...array];
        renderBars();
        clearHighlights();
        resetMetrics();
        stopTimer();
        
        // Update all displays
        updateInputDisplay();
        updateCurrentDisplay();
        updateOutputDisplay();
        
        elements.status.textContent = `Generated ${distribution} array with ${size} elements.`;
      }

      function updateAlgorithmInfo() {
        const algo = elements.algorithm.value;
        const info = algorithmInfo[algo];
        
        elements.complexityInfo.textContent = `Time: ${info.timeComplexity} | Space: ${info.spaceComplexity}`;
        elements.algoDescription.textContent = info.description;
      }

      // Control Functions
      async function startSorting() {
        if (isRunning) return;
        
        isRunning = true;
        isPaused = false;
        elements.startBtn.disabled = true;
        elements.pauseBtn.disabled = false;
        elements.stopBtn.disabled = false;
        elements.generateBtn.disabled = true;
        elements.shuffleBtn.disabled = true;
        
        clearHighlights();
        resetMetrics();
        
        const algorithm = elements.algorithm.value;
        elements.status.textContent = `Sorting with ${algorithmInfo[algorithm].name}...`;
        
        try {
          switch (algorithm) {
            case 'bubble': await bubbleSort(); break;
            case 'selection': await selectionSort(); break;
            case 'insertion': await insertionSort(); break;
            case 'merge': await mergeSort(); break;
            case 'quick': await quickSort(); break;
            case 'heap': await heapSort(); break;
            case 'shell': await shellSort(); break;
            case 'cocktail': await cocktailSort(); break;
            case 'comb': await combSort(); break;
            case 'radix': await radixSort(); break;
          }
          
          if (isRunning) {
            elements.status.textContent = 'Sorting completed!';
            playSound(523.25, 200, 'sine'); // C5 note
            setTimeout(() => playSound(659.25, 200, 'sine'), 100); // E5 note
            setTimeout(() => playSound(783.99, 300, 'sine'), 200); // G5 note
          }
        } catch (error) {
          console.error('Sorting error:', error);
          elements.status.textContent = 'Sorting interrupted.';
        }
        
        stopSorting();
      }

      function pauseSorting() {
        if (!isRunning) return;
        
        isPaused = !isPaused;
        elements.pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
        elements.status.textContent = isPaused ? 'Sorting paused.' : 'Sorting resumed.';
        
        if (isPaused) {
          playSound(440, 150, 'sine'); // A4 note
        } else {
          playSound(523.25, 150, 'sine'); // C5 note
        }
      }

      function stopSorting() {
        isRunning = false;
        isPaused = false;
        
        elements.startBtn.disabled = false;
        elements.pauseBtn.disabled = true;
        elements.pauseBtn.textContent = 'Pause';
        elements.stopBtn.disabled = true;
        elements.generateBtn.disabled = false;
        elements.shuffleBtn.disabled = false;
        
        stopTimer();
        
        if (elements.status.textContent.includes('interrupted') || elements.status.textContent.includes('stopped')) {
          // Reset array to original state
          array = [...originalArray];
          renderBars();
          clearHighlights();
          elements.status.textContent = 'Sorting stopped. Array reset to original state.';
        }
      }

      function shuffleArray() {
        if (isRunning) return;
        
        array = shuffle(array);
        renderBars();
        clearHighlights();
        resetMetrics();
        stopTimer();
        
        elements.status.textContent = 'Array shuffled.';
        playSound(330, 100, 'triangle');
      }

      function exportArray() {
        const dataStr = JSON.stringify(array);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = 'sorting-array.json';
        link.click();
        
        URL.revokeObjectURL(url);
        elements.status.textContent = 'Array exported successfully.';
      }

      function importArray() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const importedArray = JSON.parse(e.target.result);
              if (Array.isArray(importedArray) && importedArray.every(x => typeof x === 'number')) {
                array = importedArray;
                originalArray = [...array];
                elements.arraySize.value = array.length;
                elements.sizeValue.textContent = array.length;
                renderBars();
                clearHighlights();
                resetMetrics();
                stopTimer();
                elements.status.textContent = `Array imported successfully. ${array.length} elements loaded.`;
              } else {
                elements.status.textContent = 'Invalid array format.';
              }
            } catch (error) {
              elements.status.textContent = 'Error importing array.';
            }
          };
          reader.readAsText(file);
        };
        
        input.click();
      }

      // Theme Functions
      function setTheme(theme) {
        document.body.setAttribute('data-theme', theme);
        
        // Update theme button states
        document.querySelectorAll('.theme-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.theme === theme);
        });
        
        // Store theme preference
        localStorage.setItem('sorting-visualizer-theme', theme);
        
        // Re-render bars to apply new colors
        if (array.length > 0) {
          renderBars();
        }
      }

      // Event Listeners
      elements.algorithm.addEventListener('change', updateAlgorithmInfo);
      
      elements.arraySize.addEventListener('input', (e) => {
        elements.sizeValue.textContent = e.target.value;
      });
      
      elements.speed.addEventListener('input', (e) => {
        elements.speedValue.textContent = e.target.value;
        animationSpeed = parseInt(e.target.value);
      });
      
      elements.distribution.addEventListener('change', (e) => {
        elements.customInputGroup.style.display = e.target.value === 'custom' ? 'block' : 'none';
      });
      
      elements.generateBtn.addEventListener('click', generateNewArray);
      elements.shuffleBtn.addEventListener('click', shuffleArray);
      elements.startBtn.addEventListener('click', startSorting);
      elements.pauseBtn.addEventListener('click', pauseSorting);
      elements.stopBtn.addEventListener('click', () => {
        elements.status.textContent = 'Sorting stopped by user.';
        stopSorting();
      });
      
      elements.stepMode.addEventListener('change', (e) => {
        elements.stepControls.classList.toggle('active', e.target.checked);
      });
      
      elements.soundToggle.addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        elements.soundToggle.style.opacity = soundEnabled ? '1' : '0.5';
        
        if (soundEnabled && !audioContext) {
          initAudio();
        }
        
        playSound(440, 100, 'sine');
      });
      
      elements.exportBtn.addEventListener('click', exportArray);
      elements.importBtn.addEventListener('click', importArray);
      
      // Theme button event listeners
      document.querySelectorAll('.theme-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setTheme(btn.dataset.theme);
        });
      });
      
      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
        
        switch (e.key.toLowerCase()) {
          case ' ':
            e.preventDefault();
            if (isRunning) {
              pauseSorting();
            } else {
              startSorting();
            }
            break;
          case 's':
            e.preventDefault();
            if (!isRunning) startSorting();
            break;
          case 'p':
            e.preventDefault();
            if (isRunning) pauseSorting();
            break;
          case 'r':
            e.preventDefault();
            if (!isRunning) generateNewArray();
            break;
          case 'h':
            e.preventDefault();
            if (!isRunning) shuffleArray();
            break;
          case 'escape':
            e.preventDefault();
            if (isRunning) {
              elements.status.textContent = 'Sorting stopped by user.';
              stopSorting();
            }
            break;
        }
      });
      
      // Window resize handler
      window.addEventListener('resize', () => {
        if (array.length > 0) {
          renderBars();
        }
      });

      // Input/Output Display Functions
      function updateInputDisplay() {
        const inputValuesEl = document.getElementById('inputValues');
        const inputMinEl = document.getElementById('inputMin');
        const inputMaxEl = document.getElementById('inputMax');
        const inputAvgEl = document.getElementById('inputAvg');
        
        // Clear previous values
        inputValuesEl.innerHTML = '';
        
        // Add array values
        originalArray.forEach((value, index) => {
          const valueEl = document.createElement('div');
          valueEl.className = 'array-value';
          valueEl.textContent = value;
          valueEl.title = `Index: ${index}, Value: ${value}`;
          valueEl.addEventListener('click', () => {
            highlightBarByIndex(index);
            playSound(200 + value * 3, 150);
          });
          inputValuesEl.appendChild(valueEl);
        });
        
        // Update stats
        const min = Math.min(...originalArray);
        const max = Math.max(...originalArray);
        const avg = (originalArray.reduce((a, b) => a + b, 0) / originalArray.length).toFixed(1);
        
        inputMinEl.textContent = min;
        inputMaxEl.textContent = max;
        inputAvgEl.textContent = avg;
      }

      function updateCurrentDisplay() {
        const currentValuesEl = document.getElementById('currentValues');
        const sortedPercentageEl = document.getElementById('sortedPercentage');
        const currentPositionEl = document.getElementById('currentPosition');
        
        // Clear previous values
        currentValuesEl.innerHTML = '';
        
        // Add current array values
        array.forEach((value, index) => {
          const valueEl = document.createElement('div');
          valueEl.className = 'array-value';
          valueEl.textContent = value;
          valueEl.title = `Index: ${index}, Value: ${value}`;
          valueEl.id = `current-value-${index}`;
          
          // Check if this position is sorted
          const bar = elements.barsContainer.children[index];
          if (bar && bar.classList.contains('sorted')) {
            valueEl.classList.add('sorted');
          }
          
          valueEl.addEventListener('click', () => {
            highlightBarByIndex(index);
            playSound(200 + value * 3, 150);
          });
          currentValuesEl.appendChild(valueEl);
        });
        
        // Calculate sorted percentage
        const sortedBars = elements.barsContainer.querySelectorAll('.bar.sorted').length;
        const percentage = Math.round((sortedBars / array.length) * 100);
        sortedPercentageEl.textContent = `${percentage}%`;
        
        // Update current position (if sorting)
        if (isRunning) {
          currentPositionEl.textContent = `Step ${currentStep || 0}`;
        } else {
          currentPositionEl.textContent = '-';
        }
      }

      function updateOutputDisplay() {
        const outputValuesEl = document.getElementById('outputValues');
        const outputStatusEl = document.getElementById('outputStatus');
        const efficiencyEl = document.getElementById('efficiency');
        
        // Clear previous values
        outputValuesEl.innerHTML = '';
        
        if (isRunning) {
          outputStatusEl.textContent = 'Sorting...';
          efficiencyEl.textContent = '-';
          return;
        }
        
        // Check if array is sorted
        const isSorted = array.every((val, i, arr) => i === 0 || arr[i - 1] <= val);
        
        if (isSorted && (comparisons > 0 || swaps > 0)) {
          // Show final sorted array
          array.forEach((value, index) => {
            const valueEl = document.createElement('div');
            valueEl.className = 'array-value sorted';
            valueEl.textContent = value;
            valueEl.title = `Final position: ${index}, Value: ${value}`;
            valueEl.addEventListener('click', () => {
              highlightBarByIndex(index);
              playSound(200 + value * 3, 150);
            });
            outputValuesEl.appendChild(valueEl);
          });
          
          outputStatusEl.textContent = 'Completed';
          
          // Calculate efficiency (operations per element)
          const totalOps = comparisons + swaps;
          const efficiency = (totalOps / array.length).toFixed(1);
          efficiencyEl.textContent = `${efficiency} ops/element`;
        } else {
          outputStatusEl.textContent = 'Not Started';
          efficiencyEl.textContent = '-';
        }
      }

      function highlightBarByIndex(index) {
        // Clear previous highlights
        const bars = elements.barsContainer.children;
        Array.from(bars).forEach(bar => bar.classList.remove('selected'));
        
        // Highlight selected bar
        if (bars[index]) {
          bars[index].classList.add('selected');
          setTimeout(() => {
            bars[index].classList.remove('selected');
          }, 2000);
        }
      }

      function highlightCurrentValues(indices, className) {
        indices.forEach(index => {
          const valueEl = document.getElementById(`current-value-${index}`);
          if (valueEl) {
            valueEl.classList.remove('comparing', 'swapping', 'highlight');
            valueEl.classList.add(className);
            setTimeout(() => {
              if (valueEl) {
                valueEl.classList.remove(className);
              }
            }, 500);
          }
        });
      }

      function showValueComparison(index1, index2, operation) {
        const comparisonEl = document.querySelector('.value-comparison') || createComparisonElement();
        const value1 = array[index1];
        const value2 = array[index2];
        
        let text = '';
        switch (operation) {
          case 'compare':
            text = `Comparing: ${value1} ${value1 > value2 ? '>' : value1 < value2 ? '<' : '='} ${value2}`;
            break;
          case 'swap':
            text = `Swapping: ${value1} ↔ ${value2}`;
            break;
        }
        
        comparisonEl.textContent = text;
        comparisonEl.classList.add('show');
        
        setTimeout(() => {
          comparisonEl.classList.remove('show');
        }, 1000);
      }

      function createComparisonElement() {
        const comparisonEl = document.createElement('div');
        comparisonEl.className = 'value-comparison';
        elements.barsContainer.appendChild(comparisonEl);
        return comparisonEl;
      }
      
      // Initialize
      function init() {
        // Load saved theme
        const savedTheme = localStorage.getItem('sorting-visualizer-theme') || 'dark';
        setTheme(savedTheme);
        
        // Initialize audio
        initAudio();
        
        // Generate initial array
        generateNewArray();
        
        // Update algorithm info
        updateAlgorithmInfo();
        
        // Set initial values
        animationSpeed = parseInt(elements.speed.value);
        
        elements.status.textContent = 'Ready to sort! Select an algorithm and click Start.';
        
        // Initialize displays
        updateInputDisplay();
        updateCurrentDisplay();
        updateOutputDisplay();
        
        // Add welcome animation
        setTimeout(() => {
          const bars = elements.barsContainer.children;
          Array.from(bars).forEach((bar, index) => {
            setTimeout(() => {
              bar.style.animation = 'bounce 0.6s ease-out';
              playSound(200 + (array[index] * 3), 50, 'sine');
            }, index * 20);
          });
        }, 500);
      }
      
      // Start the application
      init();
    </script>
  </body>
</html>